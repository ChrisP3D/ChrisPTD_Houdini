<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="CP3D_TD_Scripts" label="TD Scripts">
    <memberTool name="overwrite_startup_hip"/>
    <memberTool name="Open Parent Type Properties"/>
    <memberTool name="Open Parent Parameter Window"/>
    <memberTool name="test"/>
    <memberTool name="Create Sop Import"/>
    <memberTool name="Spare Input to Nearest Meta Data"/>
    <memberTool name="setGeoSpreadsheetToName"/>
    <memberTool name="parmToMultiParm"/>
    <memberTool name="shelf_toggledunders"/>
    <memberTool name="insertdunders"/>
    <memberTool name="removedunders"/>
    <memberTool name="multiParmRef"/>
    <memberTool name="tool_4"/>
    <memberTool name="object_merge"/>
    <memberTool name="tool_7"/>
    <memberTool name="tool_8"/>
    <memberTool name="ConvertAllParms"/>
    <memberTool name="remove expressions"/>
    <memberTool name="tool_9"/>
    <memberTool name="prepend parm name string"/>
    <memberTool name="tool_10"/>
    <memberTool name="tool_11"/>
    <memberTool name="MultiNodeConvertToMultiparm"/>
    <memberTool name="mergeMultipleHips"/>
    <memberTool name="megascan_Mat"/>
  </toolshelf>

  <toolshelf name="vellumSetups" label="Vellum Setups">
    <memberTool name="geo8"/>
    <memberTool name="EntgmaVellumSetups"/>
  </toolshelf>

  <toolshelf name="TopSetups" label="TopSetups">
    <memberTool name="topnet"/>
    <memberTool name="topnet0"/>
  </toolshelf>

  <toolshelf name="rocks" label="Rock Creation">
    <memberTool name="geo2"/>
    <memberTool name="geo5"/>
  </toolshelf>

  <toolshelf name="miscSetups" label="Misc">
    <memberTool name="geo7"/>
    <memberTool name="subnet0"/>
    <memberTool name="geo9"/>
    <memberTool name="geo10"/>
    <memberTool name="geo11"/>
    <memberTool name="geo12"/>
    <memberTool name="geo13"/>
    <memberTool name="geo15"/>
    <memberTool name="geo16"/>
    <memberTool name="geo17"/>
    <memberTool name="geo18"/>
    <memberTool name="geo27"/>
    <memberTool name="geo28"/>
  </toolshelf>

  <toolshelf name="instancetools" label="Instancing Setups">
    <memberTool name="scatteringNew"/>
    <memberTool name="subnet"/>
    <memberTool name="geo"/>
    <memberTool name="geo0"/>
    <memberTool name="geo1"/>
    <memberTool name="geo14"/>
  </toolshelf>

  <toolshelf name="Glyphs" label="Glyphs">
    <memberTool name="geo4"/>
    <memberTool name="geo6"/>
  </toolshelf>

  <tool name="Open Parent Type Properties" label="Open Parent Type Properties" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_ui

cph_ui.openParentTypeProperties()]]></script>
  </tool>

  <tool name="parmToMultiParm" label="ConvertToMultiParm" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[]]></script>
  </tool>

  <tool name="test" label="TestScript" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou

import weakref
from datetime import datetime
from time import gmtime, strftime

# Global dictionary to store callbacks

import inspect


def get_current_line():
    # Get the current frame
    frame = inspect.currentframe()
    # Get the caller's frame
    caller_frame = frame.f_back
    # Get the line number from the caller's frame
    line_number = caller_frame.f_lineno
    return line_number


# Call the function to initialize the session variables


###Utilities
#
#
#TODO FILTER FOR SURFACE NODES INSTEAD OF MATERIAL NETWORKS

def filterHasMatLibParent(node):
    if node.parent().type().name() == 'materiallibrary' or node.parent().type().name() == 'matnet':
        return True

def filterMtlxSurfaces(node):
    if node.type().name() == 'mtlxstandard_surface':
        return True
         
def find_node_starting_with(network, prefix):
    for node in network.children():
        if node.name().lower().startswith(prefix.lower()):
            return node
    return None
    
#Callbacks
#
#
#ADD


def initCallbacks(node):
    # cleanup_callbacks(node)
    if len(node.eventCallbacks()):
        node.removeAllEventCallbacks()
    else:
        node.addEventCallback((hou.nodeEventType.InputRewired,),onPreviewInputChanged)

def onPreviewInputChanged(node, event_type, **kwargs):
    """Calls convertPreviewInputsToTextureOps. Gets the node be"""
    
    convertPreviewInputsToTextureOps(node, bypass_prompt=True)


###Session Variables
#
#

def setSessionVariables(matnet, surface_op, disp_op, output_op):
    hou.session.matnet = matnet
    hou.session.surface_op = surface_op
    hou.session.disp_op = disp_op
    hou.session.output_op = output_op
    hou.session.previous_matnet_destination = True

def getSessionRefs():
    if hou.session.initialized:
        matnet = hou.session.matnet  
        surface_op = hou.session.surface_op  
        disp_op = hou.session.disp_op
        output_op = hou.session.output_op
        
        return matnet,surface_op,disp_op,output_op 
# def setSessionVariables(matnet, surface_op, disp_op, output_op):
#     hou.session.matnet = weakref.ref(matnet)
#     hou.session.surface_op = weakref.ref(surface_op)
#     hou.session.disp_op = weakref.ref(disp_op)
#     hou.session.output_op = weakref.ref(output_op)

# def getSessionRefs():
#     if hou.session.initialized:
#         return (hou.session.matnet() if hou.session.matnet else None,
#                 hou.session.surface_op() if hou.session.surface_op else None,
#                 hou.session.disp_op() if hou.session.disp_op else None,
#                 hou.session.output_op() if hou.session.output_op else None)
        
def initSessionVars():
    #Flow
    if not hasattr(hou.session, 'initialized'):
        hou.session.initialized = True
        
    if not hasattr(hou.session, 'previous_matnet_destination'):
        hou.session.previous_matnet_destination = False
    
    if not hasattr(hou.session, 'created_mtlx_nodes'):
        hou.session.created_mtlx_nodes = []

    if not hasattr(hou.session, 'io_map'):
        hou.session.io_map = {}

    #Ops
    if not hasattr(hou.session, 'matnet'):
        hou.session.matnet = None
    
    if not hasattr(hou.session, 'surface_op'):
        hou.session.surface_op = None
    
    if not hasattr(hou.session, 'disp_op'):
        hou.session.disp_op = None
    
    if not hasattr(hou.session, 'output_op'):
        hou.session.output_op = None
    


def refreshInput(node):
    pass
    
def rewireOutput(node, output_index = 0):
    output = node.outputs()[output_index]
    output.setInput(0,None)
    time.sleep(1)
    output.setInput(0,node)

def setInputNamesForRenderEngine(node, render_engine = 'karma'):
    if not hasattr(hou.session, 'io_map'):
        hou.session.io_map = {}

    cop_input_names = list(node.inputNames())
  
    if render_engine == 'karma':
        # Manual renaming of preview mat cop
        for i in range(len(cop_input_names)):
            name = cop_input_names[i]
            if name == 'basecolor':
                name = 'base_color'
            elif name == 'spec_color':
                name = 'specular_color'
            elif name == 'roughness':
                name = 'specular_roughness'
            elif 'sss' in name:
                segs = name.split('sss')
                segs[0] = 'subsurface'
                name = ''.join(segs)
                if '_amount' in name:
                    name = 'subsurface'
            cop_input_names[i] = name
    
    elif render_engine == 'redshift':
        pass
    elif render_engine == 'octane':
        pass
    elif render_engine == 'arnold':
        pass
    elif render_engine == 'vray':
        pass
    else:
        pass
    # Inits to None, populated every time a new mtlx image node is generated
    hou.session.io_map = {name: None for name in cop_input_names}
    
    return cop_input_names

def createMtlxNode(network, cop, datatype, input_name):
    """
    Creates a MaterialX (mtlx) image node in the specified network if it doesn't already exist, 
    and sets its parameters based on the provided datatype and cop node.

    Args:
        network (hou.Node): The Houdini node network where the new mtlximage node will be created.
        cop (hou.Node): The COP (Compositing) node used as the source for the image file path.
        datatype (str): The datatype of the image. Accepted values are 'Mono', 'RGB', 'RGBA', and 'Geometry'.
        input_name (str): The name to assign to the new mtlximage node. Each name is derived from the COP preview material input

    Returns:
        hou.Node: The created or existing mtlximage node.

    Notes:
        - If a node with the specified input_name already exists in the network, that node is returned.
        - The function keeps track of created nodes in hou.session.created_mtlx_nodes.
        - The function updates hou.session.io_map with the mapping from input_name to the created node.
        - The function sets the last created node and its state in hou.session.
        - If an unknown datatype is provided, a warning message is printed.
    """

    cop_signature_key = {
        'Mono': 'default',
        'RGB': 'color3',
        'RGBA': 'color4',
        'Geometry': None
    }

    # Check if a node with this name already exists
    existing_node = network.node(input_name)
    if existing_node:
        return existing_node

    # Create Node
    texture_op = network.createNode('mtlximage')
    texture_op.setName(input_name, unique_name=True)
    
    hou.session.io_map[input_name] = texture_op 
    if not hasattr(hou.session, 'created_mtlx_nodes'):
        hou.session.created_mtlx_nodes = []
    hou.session.created_mtlx_nodes.append(texture_op)
    
    # Set parms
    if datatype in cop_signature_key:
        texture_op.parm('signature').set(cop_signature_key[datatype])
    else:
        print(f"Warning:createMtlxNode() Unknown datatype '{datatype}' for input '{input_name}'")
    
    texture_op.parm('file').set(f'op:{cop.path()}')
    
    texture_op.setSelected(1)
    texture_op.parent().layoutChildren()
    
    return texture_op

def removeEmptySurfaceInputs(preview_input_data, cop_input_names):
    """
    Removes unused MaterialX surface inputs from the Houdini session based on the provided COP input data and names.

    Args:
        cop_input_data (list): A list of dictionaries, each containing input data with a 'to_index' key representing the index of the COP input.
        cop_input_names (list): A list of strings representing the names of each input of the preview COP.

    Notes:
        - Named surface inputs are derived from the cop_input_data and cop_input_names. Should be passed from the output of setInputNamesForRenderEngine()
        - Nodes in hou.session.created_mtlx_nodes that are not listed in the named surface inputs are destroyed.
        - Special handling is applied to nodes with 'height' in their name to check and destroy related 'mtlxdisplacement' inputs.
        - The parent node's children are laid out after processing, if applicable.
        - The function updates hou.session.created_mtlx_nodes to only include the nodes that were kept.
    """
    """Cop input names are strings representing each input of the preview cop"""

    
    preview_input_names = [cop_input_names[input['to_index']] for input in preview_input_data]

    
    nodes_to_keep = []
    parent_node = None
    
    if not hasattr(hou.session, 'created_mtlx_nodes'):
        hou.session.created_mtlx_nodes = []
    for node in hou.session.created_mtlx_nodes:
        node_repr = f"Node of type {type(node)}"
        

        if node is None:
            hou.ui.displayMessage(f'Node is none : {node}')
            continue

        node_path = node.path()
        node_name = node.name()
        node_repr = f"Node '{node_name}' at {node_path}"
        
        if node.isInsideLockedHDA():
            print(f"Skipping node (inside locked HDA): {node_repr}")
            continue



        
        if node_name not in preview_input_names:
            print(f"Destroying node: {node_repr}")
            parent_node = node.parent()  # Store the parent before destroying the node
            
            #destroy displacement op if we destroy the displacement texture
            if 'height' in node_name:
                for input in output_op.inputs():
                    if 'mtlxdisplacement' in input.name():
                        input.destroy()
            else:
                node.destroy()

        else:
            print(f"Keeping node: {node_repr}")
            nodes_to_keep.append(node)
            if parent_node is None:
                parent_node = node.parent()  # Store the parent of a kept node

    node.parent().layoutChildren()
    if not hasattr(hou.session, 'created_mtlx_nodes'):
            hou.session.created_mtlx_nodes = []
    for node in hou.session.created_mtlx_nodes:
            if node is None or not node.isValid():
                continue
    hou.session.created_mtlx_nodes = nodes_to_keep
    
    print(f'removeEmptySurfaceInputs made nodes_to_keep as {nodes_to_keep} and assigned it to hou.session.created_mtlx_nodes')
    
    

    
###Scripted UI
#
#
#TODO Refactor this to only search for surface vop nodes
def getMatNetDestination():
    """
    Prompts the user to select a Material X (Mtlx) destination through a custom confirmation dialog.

    The function presents a dialog with options to:
    - Update the previous Material X destination
    - Choose a Karma Material
    - Generate a new Material X node

    Based on the user's choice, the function performs the following:
    1. **Update Previous Destination**: Returns previously stored Material X nodes from `hou.session`, if available.
    2. **Choose Karma Material**: Allows the user to select a Material X node or generates a new one if no appropriate nodes are found.
    3. **Generate**: Creates and returns a new default Material X node.

    Returns:
        tuple: A tuple containing:
            - `matnet` (hou.Node): The Material X node (Material Network).
            - `surface_op` (hou.Node): The Material X surface operation node.
            - `disp_op` (hou.Node): The Material X displacement operation node.
            - `output_op` (hou.Node): The Material X output node.
        
        Returns `(None, None, None, None)` if the user cancels the operation.

    Raises:
        AttributeError: If there is an issue accessing `hou.session.previous`.
        hou.ObjectWasDeleted: If a node in `hou.session.previous` was deleted.
    """

    matnet = surface_op = disp_op = output_op = None

    while True:
        if hasattr(hou.session, 'previous_matnet_destination'):
            destination = hou.ui.displayCustomConfirmation(
                "Pick a Material X Destination", 
                buttons=('Update Previous Destination', 'Choose Karma Material', 'Generate', 'Cancel'),
                default_choice=0,
                close_choice=3,
                title="Pick Destination"
            )
        else:
            destination = hou.ui.displayCustomConfirmation(
                "", 
                buttons=('Choose Karma Material', 'Generate', 'Cancel'),
                default_choice=0,
                close_choice=2,
                title="Pick Destination"
            )
            destination += 1  # Adjust for the missing "Update Previous" option
        
        if destination in (3, -1):  # Cancel or close
            return None, None, None, None
        
        if destination == 0:  # Update Previous Destination
            try:
                if hou.session.previous_matnet_destination:
                    return (hou.session.matnet, hou.session.surface_op, 
                            hou.session.disp_op, hou.session.output_op)
            except (AttributeError, hou.ObjectWasDeleted):
                print(f"Warning: hou.sesion.previous is set to False")

        
        if destination == 1:  # Choose Karma Material
            found_matlibs = any(n.parent().type().name() in ['materiallibrary', 'matnet'] 
                                for n in hou.node('/').allSubChildren())
            if found_matlibs:
                matnet = hou.node(hou.ui.selectNode(
                    custom_node_filter_callback=filterHasMatLibParent, 
                    title="Choose a Mtlx standard surface"
                ))
                if not matnet:
                    continue
                surface_op = (find_node_starting_with(matnet, 'mtlxstandard_surface') or 
                                matnet.createNode('mtlxstandard_surface'))
            #TODO import generate function to create karmamat builder
            else:

                matnet = generateMatAtDefault()
        
        elif destination == 2:  # Generate
            matnet = generateMatAtDefault()
        
        if matnet:
            disp_op = (find_node_starting_with(matnet, 'mtlxdisplacement') or 
                        matnet.createNode('mtlxdisplacement'))
            output_op = matnet.node('Material_Outputs_and_AOVs')
            setSessionVariables(matnet, surface_op, disp_op, output_op)
            return matnet, surface_op, disp_op, output_op

###Main Script
#
#
def convertPreviewInputsToTextureOps(node, bypass_prompt=False):
    print(f"""Begin convertPreviewInputs...
          hou.session.previous_matnet_destination: {hou.session.previous_matnet_destination}
          hou.session.created_mtlx_nodes : {hou.session.created_mtlx_nodes}
          """)
    # Check if we should bypass the prompt
    if bypass_prompt:
            matnet, surface_node, disp_op, output_op = getSessionRefs()

    else:
        matnet, surface_node, disp_op, output_op = getMatNetDestination()

    if matnet is None or surface_node is None or output_op is None:
        hou.ui.displayMessage('matnet is None or surface_node is None or output_op is None')
        return

    #convert the input string names to match the names of the input strings on the shader surface op
    cop_input_names = setInputNamesForRenderEngine(node)

    #Signatures
    cop_preview_input_data_types = node.inputDataTypes()
    idx_data_types = dict(enumerate(cop_preview_input_data_types))

    preview_input_data = node.inputsAsData()

    # Remove empty inputs first
    removeEmptySurfaceInputs(preview_input_data, cop_input_names)

    # Loop over Preview Material COP Input data
    
    for input in preview_input_data:
        preview_input_index = input['to_index']
        input_cop = node.parent().node(input["from"]) 
        input_cop_signature = idx_data_types[preview_input_index]

        # Geo
        if preview_input_index == 0:
            cop_sopimport = node.parent().node(input["from"])
            if cop_sopimport:
                geo_path = cop_sopimport.parm('soppath').evalAsString()

        ###Normal Map
        elif preview_input_index == 15:
            # Find existing normalmap node
            normalmap_mtlx_node = find_node_starting_with(matnet, 'mtlxnormalmap')
            
            if normalmap_mtlx_node is None:
                normalmap_mtlx_node = matnet.createNode('mtlxnormalmap')
                surface_node.setNamedInput('normal', normalmap_mtlx_node, 0)
            if not hasattr(hou.session, 'created_mtlx_nodes'):
                hou.session.created_mtlx_nodes = []
            hou.session.created_mtlx_nodes.append(normalmap_mtlx_node)
            
            # Get or create the normal image node
            normal_texture_node = find_node_starting_with(matnet, 'normal')
            if normal_texture_node is None:
                normal_texture_node = createMtlxNode(matnet, input_cop, input_cop_signature, 'normal')
                #Override
                normal_texture_node.parm('signature').set('vector3')

            # Set the position of the normal image node to aid in layout
            normalmap_pos = normalmap_mtlx_node.position()
            normal_texture_node.setPosition((normalmap_pos[0] - 2, normalmap_pos[1]))

            # Connect the texture to the normal map 
            normalmap_mtlx_node.setInput(0, normal_texture_node,0)

            # Ensure normalmap is connected to the surface node
            if surface_node.input('normal') != normalmap_mtlx_node:
                surface_node.setNamedInput('normal', normalmap_mtlx_node,'out')


       ###Displacement
        elif preview_input_index == 16:
            displacement_texture_node = matnet.node('height') or createMtlxNode(matnet, input_cop, input_cop_signature, 'height')
            if not hasattr(hou.session, 'created_mtlx_nodes'):
                hou.session.created_mtlx_nodes = []
            hou.session.created_mtlx_nodes.append(displacement_texture_node)


            disp_op = find_node_starting_with(matnet,"mtlxdisplacement") or matnet.createNode('mtlxdisplacement')
            hou.session.disp_op = disp_op
            
            # Connect nodes
            disp_op.setInput(0, displacement_texture_node,0)

            disp_input = next((i for i, input in enumerate(output_op.inputs()) if input and 'displacement' in input.name().lower()), None)
            if disp_input is not None:
                output_op.setInput(disp_input, disp_op,0)
            else:
                output_op.setInput(len(output_op.inputs()), disp_op,0)
            

        else:
            surf_input_name = cop_input_names[preview_input_index]
            texture_node = createMtlxNode(matnet, input_cop, input_cop_signature, surf_input_name)
            try:
                surface_node.setNamedInput(surf_input_name, texture_node, 0)
            except hou.InvalidInput:
                print(f'Warning: surf_input_name "{surf_input_name}" does not exist on the surface node')



###External Drivers
#
#
def main(node=None):
    

    try:
        initSessionVars()
        if node is None:
            if len(hou.selectedNodes()) == 1:
                node = hou.selectedNodes()[0]

        if node.type().name() != 'previewmaterial':
            hou.ui.displayMessage("Please select a Copernicus Preview Material node")
            return
    
        initCallbacks(node)

        # Check if the node already has a callback
        if len(node.eventCallbacks()) > 0:
            
            convertPreviewInputsToTextureOps(node, bypass_prompt=True)
        else:
            convertPreviewInputsToTextureOps(node, bypass_prompt=False)
    except Exception as e:
        hou.ui.displayMessage(f"An error occurred main(): {str(e)}")
    finally:
        # This ensures cleanup happens even if an error occurs
        # cleanup_callbacks(node)
        
        pass

main()]]></script>
  </tool>

  <tool name="overwrite_startup_hip" label="Overwrite Startup Hip" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
from cph import cph_setDefaultProject

cph_setDefaultProject.setDefaultProject()]]></script>
  </tool>

  <tool name="Create Sop Import" label="Create Sop Import" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[# Creates a sopimport Lop with the selected nodes as a reference. 
# If a lopnet is one of the selected nodes, the sopimports will be created inside of the selected lopnet.
# If no lopnets are detected the sopimports will automatically be created in /stage

from cph import cph_NetworkUtils as cph_nu

cph_nu.SelectedSopsToStage()
]]></script>
  </tool>

  <tool name="Spare Input to Nearest Meta Data" label="Spare Input To nearest MetaData" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as cpparm
if len(hou.selectedNodes()):
    node = hou.selectedNodes()[0]
    
# temp = cpparm.createSpareInputParmTemplate(digit=0)
cpparm.createSpareInputParm(node)



]]></script>
  </tool>

  <tool name="shelf_toggledunders" label="Toggle Dunders" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as pu


# pu.Dunderize(method='toggle')

parm = kwargs["parms"][0]
pu.ToggleDunders(parm)]]></script>
  </tool>

  <tool name="insertdunders" label="Insert Dunders" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as pu


pu.Dunderize(method='insert')]]></script>
  </tool>

  <tool name="removedunders" label="Remove Dunders" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as pu


pu.Dunderize(method='remove')]]></script>
  </tool>

  <tool name="multiParmRef" label="MultiParmRef" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as pu

nodes = hou.selectedNodes()

for node in nodes:
    for parm in node.parms():
        if 'spare_input' not in parm.name() and not parm.isShowingExpression():
            if not pu.isEditor(parm):
                pu.convertParmStringToMultiParm(parm)
]]></script>
  </tool>

  <tool name="tool_4" label="savehipworkingfile" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[import hou
import os
from cph import cph_sys, cph_Utils

def writeDefaultProject(_hipfile_path, write = 1):
    scripts_folder = cph_sys.getScriptsFolder()
    filepath_target = os.path.join(scripts_folder, '123.py')  
    _hipfile_path = _hipfile_path.replace("\\", "/")
    payload = f'hou.hipFile.merge("{_hipfile_path}")'
    if write:
        with open(filepath_target, 'w') as file:
            file.write(payload)
    return payload

def useCurrentHipCallback():
    hipfile_path = hou.hipFile.path()
    writeDefaultProject(hipfile_path)
    hou.ui.displayMessage(f'Current Project Set as Default: {hipfile_path}')

def useSelectHipFileCallback():
    file_path = hou.ui.selectFile()
    if file_path:
        hipfile_path = hou.text.expandString(file_path)
        writeDefaultProject(hipfile_path)
        hou.ui.displayMessage(f'Selected HIP from disk: {hipfile_path}')

def setDefaultHip(message):
    if message == 0:
            if hou.hipFile.isNewFile():
                saveprompt = hou.ui.displayMessage("Hip Must Be Saved First!", buttons=("Save","Cancel"), close_choice= 1)
                if saveprompt == 1:
                    return
                if saveprompt == 0:
                    savefile_path = hou.ui.selectFile()
                    if savefile_path:
                        hou.hipFile.save(savefile_path)      
            hipfile_path = hou.hipFile.path()
            writeDefaultProject(hipfile_path)
            hou.ui.displayMessage(f'Current Project Set as Default: {hipfile_path}')
            
            
    if message == 1:
        file_path = hou.ui.selectFile()
        if file_path:
            hipfile_path = hou.text.expandString(file_path)
            writeDefaultProject(hipfile_path)
            hou.ui.displayMessage(f'Selected HIP from disk: {hipfile_path}')
    
    if message == 2:
        scripts_folder = cph_sys.getScriptsFolder()
        scriptfile = os.path.join(scripts_folder, '123.py')  
        
        payload = writeDefaultProject(hou.hipFile.path(),write=0)
        with open(scriptfile, 'r') as file:
            content = file.read()
        print(content)
        #if 123.py is empty, houdini won't open
        if len(content) ==0:
            os.remove(scriptfile)
            return
        else: 
            updated_content = content.replace(payload, "")
            with open(scriptfile, 'w') as file:
                file.write(updated_content)

def setDefaultProject():
    message = hou.ui.displayMessage("Choose an action:", buttons=("Use Current HIP as Default_", "Select HIP from Disk","Clear and Reset to default","Cancel"), close_choice= 3)

    setDefaultHip(message)

]]></script>
    <keywordList>
      <keyword>Get Max</keyword>
    </keywordList>
  </tool>

  <tool name="object_merge" label="Object Merge" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[selnode = hou.selectedNodes()[0]

network = selnode.parent()

# objectmerges = []
# for node in network.children():
#     if node.type() == hou.sopNodeTypeCategory().nodeType('object_merge'):
#         objectmerges.append(node)
        
# objectmerges[0].parm('objpath1').set(selnode.path())

new_obj_merge = network.createNode('object_merge')

# new_obj_merge.moveToGoodPosition()


new_obj_merge.parm('objpath1').set(selnode.path())
offset = hou.Vector2([0,-100])

selnode_pos = selnode.position() 

newpos = selnode_pos + offset
print(newpos)
new_obj_merge.setPosition(newpos)

]]></script>
  </tool>

  <tool name="ConvertAllParms" label="ConvertAllToMP" icon="hicon:/SVGIcons.index?BUTTONS_adapt_h.svg">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as cpparm

if len(hou.selectedNodes()):
    node = hou.selectedNodes()[0]
    
parms = node.parms()
for parm in parms:
    if cpparm.isParmExpression(parm):
        cpparm.convertParmStringToMultiParm(parm)
    
# else:
#     node = hou.ui.selectNode(multiple_select = True)
# cpparm.convertAllParmsToMP(node)]]></script>
  </tool>

  <tool name="remove expressions" label="Remove All Expressions" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[#only run if node is selected
if len(hou.selectedNodes()):
    node = hou.selectedNodes()[0]

#Delete
for parm in node.parms():
    if len(parm.keyframes()) > 0:
        parm.deleteAllKeyframes()

# temp = cpparm.createSpareInputParmTemplate(digit=0)
# cpparm.createSpareInputParm(node)]]></script>
  </tool>

  <tool name="tool_9" label="Set All To Default" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[if len(hou.selectedNodes()):
    node = hou.selectedNodes()[0]

for parm in node.parms():
    if not parm.isAtDefault():
        parm.revertToDefaults()]]></script>
  </tool>

  <tool name="prepend parm name string" label="prepend Parm name string" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
def prepend_to_parameter_names(hda_node, prepend_string):
    parm_template_group = hda_node.parmTemplateGroup()
    new_parm_template_group = hou.ParmTemplateGroup()
    old_foldernames = []
    old_nonfoldernames = []


    for parm_template in parm_template_group.entriesWithoutFolders():
        old_name = parm_template.name()
        new_name = f"{prepend_string}{old_name}"

        parm_template.setName(new_name)
        # parm_template.setLabel(prepend_string + parm_template.label())
        new_parm_template_group.append(parm_template)
    hda_node.setParmTemplateGroup(new_parm_template_group)

    definition = hda_node.type().definition()
    definition.updateFromNode(hda_node)
    


selnodes = hou.selectedNodes()
# for node in selnodes:

hda_node = selnodes[0]
prepend_string = hou.ui.readInput("Type a prefix to add to every parameter", buttons=('OK',))
print(prepend_string[1])
prepend_to_parameter_names(hda_node, prepend_string[1])]]></script>
  </tool>

  <tool name="tool_10" label="prepend parm names" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou

def prepend_to_parameter_names(hda_node, prepend_string):
    hda_node.allowEditingOfContents()
    parm_template_group = hda_node.parmTemplateGroup()
    new_parm_template_group = hou.ParmTemplateGroup()
    old_foldernames = []
    old_nonfoldernames = []


    for parm_template in parm_template_group.entriesWithoutFolders():

        old_name = parm_template.name()
        new_name = f"{prepend_string}{old_name}"
       
        # Create a copy of the parameter template with the updated name
        updated_parm_template = parm_template.clone()

        updated_parm_template.setName(new_name)

        new_parm_template_group.append(updated_parm_template)
        parm_template_group.remove(parm_template.name())
        
    # Set the modified template group back to the node
        hda_node.setParmTemplateGroup(new_parm_template_group)

    # Save the updated HDA definition to a file
    definition = hda_node.type().definition()
    definition.updateFromNode(hda_node)
    definition.save(definition.libraryFilePath())



selnodes = hou.selectedNodes()
# for node in selnodes:

hda_node = selnodes[0]
print(hda_node)
prepend_string = 'prefix_'
prepend_to_parameter_names(hda_node, prepend_string)
]]></script>
  </tool>

  <tool name="MultiNodeConvertToMultiparm" label="MultiNodeConvertToMultiparm" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from cph import cph_parmUtils as cpparm
def convertParmTupleToMultiParm(parmTup,scheme):
    
    if scheme == hou.parmNamingScheme.Base1:
        delimits = ['1','2','3','4']
    elif scheme == hou.parmNamingScheme.XYZW:
        delimits = ['x','y','z','w']
    elif scheme == hou.parmNamingScheme.RGBA:
        delimits = ['r','g','b','a']
    elif scheme == hou.parmNamingScheme.UVW:
        delimits = ['u','v','w']
    else:
        delimits = []
        
    for i, parm in enumerate(parmTup):
        parmval = cpparm.getParmAsString(parm)
            
        spliters = ['/','.','#','ch',"chs",'"', "'",')',"(",'strcat',
                    'ch("../")', "ch('../')",'chs("../")', "chs('../')",
                    "#')",'#")',
                    'detail(',
                    'point(',
                    'vertex(',
                    'prim(','#']
        
        nums = [str(i) for i in range(10)]
        spliters += nums
        for s in spliters:
            if s in parmval:
                parmval = parmval.replace(s,"")
        for dl in delimits:
            if parmval.endswith(dl):
                parmval = parmval.replace(dl,"")
        
        
        if '#' in parmval:
            parmval = parmval.replace('#','')
        if parmtup.parmTemplate().type() ==  hou.parmTemplateType.FolderSet:   
            print(parmtup.name())
        
        if parmtup.parmTemplate().type() == hou.parmTemplateType.Folder or parmtup.parmTemplate().type() != hou.parmTemplateType.FolderSet:
 
            if len(parmtup)>1:
    
                payload = f"ch(strcat(strcat('../{parmval}',detail(-1,'iteration',0)+1),{delimits[i]}))"
            else:
                payload = f"ch(strcat('../{parmval}',detail(-1,'iteration',0)+1))" 
            parm.setExpression(payload)
for node in hou.selectedNodes():
    
    parmtups = node.parmTuples()
    for parmtup in parmtups:
        scheme = parmtup.parmTemplate().namingScheme()
        convertParmTupleToMultiParm(parmtup,scheme)

        
    
# else:
#     node = hou.ui.selectNode(multiple_select = True)
# cpparm.convertAllParmsToMP(node)]]></script>
  </tool>

  <tool name="mergeMultipleHips" label="Merge Hips(Multi)" icon="hicon:/SVGIcons.index?book.svg">
    <script scriptType="python"><![CDATA[import os
import hou

hip_extensions = (".hip", ".hiplc", ".hipnc", ".hipsc")

def find_hip_files(folder_paths):
    hip_files = []
    
    # Ensure folder_paths is a list
    if isinstance(folder_paths, str):
        folder_paths = [folder_paths]

    for folder in folder_paths:
        folder = folder.strip()
        for root, _, files in os.walk(folder):
            for filename in files:
                if filename.endswith(hip_extensions):
                    file_path = os.path.join(root, filename)
                    if os.name == 'nt':  # Convert path for Windows
                        file_path = file_path.replace("\\", "/")
                    hip_files.append(file_path)
    
    return hip_files

# Let the user select multiple directories
selected_dirs = hou.ui.selectFile(
    file_type=hou.fileType.Directory,
    title="Select directories containing hip files",
    multiple_select=True
)

# Process selected directories if any were chosen
if selected_dirs:
    # Houdini returns paths separated by semicolons, split them into a list
    folder_paths = selected_dirs.split(';')

    # Normalize paths and replace backslashes on Windows, and strip spaces
    folder_paths = [hou.expandString(folder).replace("\\", "/").strip() for folder in folder_paths]

    # Find .hip files in the selected directories
    hip_files = find_hip_files(folder_paths)

    merged = []
    failed = []
    other = []
    for hip_file in hip_files:
        try:
            print(f"Merging file: {hip_file}")
            hou.hipFile.merge(hip_file)
            merged.append(hip_file)
        except Exception as e:
            print(f"Failed to merge file {hip_file}: {e}")
            failed.append(hip_file)

    # Identify any files that are neither in merged nor failed
    for hip_file in hip_files:
        if hip_file not in merged and hip_file not in failed:
            other.append(hip_file)

    # Format the lists of files for a cleaner display
    merged_str = "\n  ".join(merged) if merged else "None"
    failed_str = "\n  ".join(failed) if failed else "None"
    other_str = "\n  ".join(other) if other else "None"

    # Display the message with formatted information
    hou.ui.displayMessage(f"""Successfully merged {len(merged)} files.
Failed to merge {len(failed)} files.
Succeeded:
  {merged_str}
Failed:
  {failed_str}
Other:
  {other_str}
""")
else:
    print("No directories selected.")
]]></script>
  </tool>
</shelfDocument>
